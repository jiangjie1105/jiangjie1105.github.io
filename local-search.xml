<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js问题积累</title>
    <link href="/2020/04/02/js%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF-1/"/>
    <url>/2020/04/02/js%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>312</title>
    <link href="/2020/03/12/312/"/>
    <url>/2020/03/12/312/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>this全面解析</title>
    <link href="/2020/01/19/this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/01/19/this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>this的绑定规则总共有下面五种：</p><ul><li>1.默认绑定（严格/非严格模式）</li><li>2.隐式绑定</li><li>3.显示绑定</li><li>4.new绑定</li><li>5.箭头函数绑定</li></ul><h1 id="1-调用位置"><a href="#1-调用位置" class="headerlink" title="1.调用位置"></a>1.调用位置</h1><p>调用位置就是函数在代码中<font color="red"><strong>被调用的位置</strong></font>(而不是声明的位置)。</p><p>查找方法：</p><ul><li>分析调用栈：调用位置就是当前正在执行的函数的<strong>前一个调用</strong>中</li></ul><pre><code>function baz() {    // 当前调用栈是：baz    // 因此，当前调用位置是全局作用域    console.log( &quot;baz&quot; );    bar(); // &lt;-- bar的调用位置}function bar() {    // 当前调用栈是：baz --&gt; bar    // 因此，当前调用位置在baz中    console.log( &quot;bar&quot; );    foo(); // &lt;-- foo的调用位置}function foo() {    // 当前调用栈是：baz --&gt; bar --&gt; foo    // 因此，当前调用位置在bar中    console.log( &quot;foo&quot; );}baz(); // &lt;-- baz的调用位置</code></pre><ul><li>使用开发者工具得到调用栈：<br>设置断点或者插入debugger；语句，运行时调试器会在那个位置暂停，同时展示当前位置的函数调用列表，这就是<font color="red">调用栈</font>，找到栈中的<font color="red">第二个元素</font>，这就是真正的调用位置。</li></ul><h1 id="2-绑定规则"><a href="#2-绑定规则" class="headerlink" title="2.绑定规则"></a>2.绑定规则</h1><p>。。。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>作用域闭包</title>
    <link href="/2020/01/18/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/"/>
    <url>/2020/01/18/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入浅出理解作用域链和闭包"><a href="#深入浅出理解作用域链和闭包" class="headerlink" title="深入浅出理解作用域链和闭包"></a>深入浅出理解作用域链和闭包</h1><ol><li>闭包的定义：<a id="more"></a>闭包是指有权访问另一个函数作用域中的变量的函数，关键在以下两点：</li></ol><ul><li>1.闭包是一个函数</li><li>2.闭包能访问另外一个函数的作用域中的变量。</li></ul><ol start="2"><li>闭包的特性</li></ol><ul><li>1.闭包可以访问当前函数以外的变量：</li></ul><pre><code>function getOuter(){  var name = &quot;zhangsan&quot;function getName(str){    console.log(str + name);}return getName(&#39;名字：&#39;);}getOuter();</code></pre><ul><li>2.即使外部函数已经返回，闭包仍能访问外部函数定义的变量</li></ul><pre><code>function getOuter(){  var date = &#39;815&#39;;  function getDate(str){    console.log(str + date);  //访问外部的date  }  return getDate;     //外部函数返回}var today = getOuter();today(&#39;今天是：&#39;);   //&quot;今天是：815&quot;today(&#39;明天不是：&#39;);   //&quot;明天不是：815&quot;</code></pre><ul><li><ol start="3"><li>闭包可以更新外部变量的值</li></ol></li></ul><pre><code>function updateCount(){  var count = 0;  function getCount(val){    count = val;    console.log(count);  }  return getCount;     //外部函数返回}var count = updateCount();count(815); //815count(816); //816</code></pre><h2 id="1-作用域链"><a href="#1-作用域链" class="headerlink" title="1.作用域链"></a>1.作用域链</h2><p>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链。</p><p><strong>作用域链和原型继承查找的区别：</strong></p><p>如果取查找一个普通对象的属性，但是在当前对象和原型中都找不到时，就会返回undefined；但查找的属性在作用域链中不存在的话就会抛出ReferenceError。</p><p>作用域链的顶端是全局对象，在全局环境中定义的变量就会绑定到全局对象中。</p><h1 id="JavaScript深入之从作用域链理解闭包"><a href="#JavaScript深入之从作用域链理解闭包" class="headerlink" title="JavaScript深入之从作用域链理解闭包"></a>JavaScript深入之从作用域链理解闭包</h1><p>MDN对闭包的定义为：<strong>闭包是那些能够访问自由变量的函数</strong></p><p>其中<strong>自由变量</strong> 是指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。</p><p>例子：</p><pre><code>function getOuter(){  var date = &#39;1127&#39;;  function getDate(str){    console.log(str + date);  //访问外部的date  }  return getDate(&#39;今天是：&#39;); //&quot;今天是：1127&quot;}getOuter();</code></pre><p>其中date既不是参数arguements，也不是局部变量，所以date是自由变量。</p><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}var foo = checkscope(); // foo指向函数ffoo();                    // 调用函数f()</code></pre><p>简要的执行过程如下：</p><ol><li><p>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</p></li><li><p>全局执行上下文初始化</p></li><li><p>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</p></li><li><p>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</p></li><li><p>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</p></li><li><p>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</p></li><li><p>f 执行上下文初始化，创建变量对象、作用域链、this等</p></li><li><p>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p></li></ol><h1 id="JavaScript深入之闭包面试题解"><a href="#JavaScript深入之闭包面试题解" class="headerlink" title="JavaScript深入之闭包面试题解"></a>JavaScript深入之闭包面试题解</h1><p>由于作用域链机制的影响，闭包只能取得内部函数的最后一个值，这引起的一个副作用就是如果内部函数在一个循环中，那么变量的值始终为最后一个值。</p><pre><code>var data = [];for (var i = 0; i &lt; 3; i++) {  data[i] = function () {    console.log(i);  };}data[0]();    // 3data[1]();    // 3data[2]();    // 3</code></pre><p>如果要强制返回预期的结果，怎么办？？？</p><h2 id="1-方法一：立即执行函数"><a href="#1-方法一：立即执行函数" class="headerlink" title="1.方法一：立即执行函数"></a>1.方法一：立即执行函数</h2><pre><code>for (var i = 0; i &lt; 3; i++) {    (function(num) {        setTimeout(function() {            console.log(num);        }, 1000);    })(i);}// 0// 1// 2</code></pre><h2 id="1-方法二：返回一个匿名函数赋值"><a href="#1-方法二：返回一个匿名函数赋值" class="headerlink" title="1.方法二：返回一个匿名函数赋值"></a>1.方法二：返回一个匿名函数赋值</h2><pre><code>var data = [];for (var i = 0; i &lt; 3; i++) {  data[i] = (function (num) {      return function(){          console.log(num);      }  })(i);}data[0]();    // 0data[1]();    // 1data[2]();    // 2</code></pre><h2 id="1-方法三：使用ES6中的let"><a href="#1-方法三：使用ES6中的let" class="headerlink" title="1.方法三：使用ES6中的let"></a>1.方法三：使用ES6中的let</h2><pre><code>var data = [];for (let i = 0; i &lt; 3; i++) {  data[i] = function () {    console.log(i);  };}data[0]();data[1]();data[2]();</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript深入执行上下文和变量对象</title>
    <link href="/2020/01/16/JavaScript%E6%B7%B1%E5%85%A5%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/01/16/JavaScript%E6%B7%B1%E5%85%A5%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端进阶之调用堆栈</title>
    <link href="/2020/01/16/%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/"/>
    <url>/2020/01/16/%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-js中的执行上下文和执行栈"><a href="#1-js中的执行上下文和执行栈" class="headerlink" title="1.js中的执行上下文和执行栈"></a>1.js中的执行上下文和执行栈</h1><a id="more"></a><p><strong>1.首先要理解什么是执行上下文，执行上下文就是当前jJavaScript代码在被解析和执行时所在环境的抽象概念</strong></p><h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>执行上下文有三种类型：</p><ul><li><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是windows对象，this指向这个全局对象</li><li><strong>函数执行上下文</strong>：存在无数个，只有函数在被调用时才会被创建，每次调用函数都会创建一个新的执行上下文</li><li><strong>Eval函数执行上下文</strong>：很少使用，不建议使用，指的是运行在eval函数中的代码</li></ul><p><strong>执行上下文就是JavaScript 在被解析和运行时环境的抽象概念，JavaScript 运行任何代码都是在执行上下文环境中运行的，执行上下文包括三个周期：创建——运行——销毁，重点说一下创建环节。</strong></p><p>创建环节（函数被调用，但未被执行），会执行三件事情</p><ul><li>创建变量对象，首先初始化函数的arguments对象，提升函数声明和变量声明，从近到远查找函数运行所需要的变量</li><li>创建作用域链，作用域就是一个独立的地盘，让变量不会相互干扰，当前作用域没有定义的变量，这成为 自由变量。自由变量会向上一直寻找，要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，如果最终没有就为undefined。这种层层之间就构成了作用域链。</li><li>确定this指向，this、apply、call的指向</li></ul><p>看下面的例子</p><pre><code>function test(arg){     // 1. 形参 arg 是 &quot;hi&quot;    // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function    console.log(arg);    var arg = &#39;hello&#39;;    function arg (){        console.log(&quot;hello world&quot;);    }    var age = &quot;word&quot;;    console.log(arg);}test(&#39;hi&#39;);</code></pre><p>上面这个例子，函数内函数声明比变量声明优先，所以arg被覆盖，并且被提升，所以第一次打印不会报错，打出了arg函数，后面变量被覆盖成为hello。</p><p>函数执行多了就会有多个执行上下文，怎么管理这些执行上下文呢？？？？</p><p>JavaScript引擎创建了执行栈来管理执行上下文，可以把执行栈认为成一个储存函数调用的栈结构，遵循的时先进后出的原则。如：<br><img src="https://user-gold-cdn.xitu.io/2019/3/17/1698ac2c8ca10784?imageslim" srcset="/img/loading.gif" alt=""><br>上面代码结果为100</p><p>再看下面的代码</p><pre><code>var a = &#39;Hello World!&#39;;function first() {    console.log(&#39;Inside first function&#39;);    second();    console.log(&#39;Again inside first function&#39;);  }function second() {    console.log(&#39;Inside second function&#39;);  }first();  console.log(&#39;Inside Global Execution Context&#39;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p>以下是我对这些代码的理解：首先，当这段js代码首次运行时，js引擎会创建一个全局执行上下文，并将其放在栈顶，此时栈只有这个全局执行上下文，然后<strong>当函数调用时（也就是代码中先调用的这个first函数）</strong>，js引擎会创建一个函数（first）的执行上下文，并将其压栈放在刚刚的全局执行上下文上方，在first函数之中又调用了second函数，这时js引擎又会创建一个新的执行函数执行上下文并将其放在执行栈的顶端，此时运行second函数，当second函数运行完之后，他的执行上下文从当前栈顶弹出，然后把执行上下文控制权交给了当前执行栈的下一个执行上下文，也就是first（）函数的执行上下文，当first（）函数执行完成后，他的执行上下文从当前的执行栈中弹出，把执行上下文控制权交给了全局执行上下文，一旦所有代码执行完毕后，js引擎就把全局执行上下文从执行栈中移除。</p><p>由此看出：</p><ul><li>JavaScript引擎是单线程执行，所有代码都是排队执行。</li><li>一开始执行的是全局代码，首先创建全局的执行上下文，然后将该执行上下文压入执行栈中。</li><li>每当执行一个函数，就会创建该函数的执行上下文，然后将其压入执行栈的顶部，函数执行完成后，执行上下文从底部退出，等待垃圾回收。</li><li>游览器js总是访问执行栈顶层的执行上下文。</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈</li></ul><p>即压栈运行</p><h1 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h1><p>执行上下文分两个阶段创建：</p><ol><li>创建阶段</li><li>执行阶段</li></ol><h2 id="创建阶段："><a href="#创建阶段：" class="headerlink" title="创建阶段："></a>创建阶段：</h2><ul><li>1.确定this的值，也被称为This Binding。</li><li>2.LexicalEnvironment（词法环境）组件被创建</li><li>3.VariableEnvironment（变量环境）组件被创建</li></ul><p>This Binding:</p><p>在全局执行上下文中，this 的值指向全局对象，在浏览器中，this 的值指向 window 对象。<br>在函数执行上下文中，this 的值取决于函数的调用方式。如果它被一个对象引用调用，那么 this 的值被设置为该对象，否则 this 的值被设置为全局对象或 undefined（严格模式下）。例如：</p><pre><code>let person = {    name: &#39;peter&#39;,    birthYear: 1994,    calcAge: function() {      console.log(2018 - this.birthYear);    }  }person.calcAge();   // &#39;this&#39; 指向 &#39;person&#39;, 因为 &#39;calcAge&#39; 是被 &#39;person&#39; 对象引用调用的。let calculateAge = person.calcAge;  calculateAge();  // &#39;this&#39; 指向全局 window 对象,因为没有给出任何对象引用</code></pre><h2 id="词法环境："><a href="#词法环境：" class="headerlink" title="词法环境："></a>词法环境：</h2><p>简而言之，词法环境是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用）</p><p>在词法环境中，有两个组成部分：（1）环境记录（environment record） （2）对外部环境的引用</p><p>环境记录是存储变量和函数声明的实际位置。<br>对外部环境的引用意味着它可以访问其外部词法环境。</p><p>词法环境有两种类型：</p><ul><li>全局环境（在全局执行上下文中）是一个没有外部环境的词法环境。全局环境的外部环境引用为 null。它拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</li><li>函数环境，用户在函数中定义的变量被存储在环境记录中。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。<br>（对环境记录和变量环境还不太清楚）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js--DOM</title>
    <link href="/2020/01/15/DOM/"/>
    <url>/2020/01/15/DOM/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.jsDom</p><a id="more"></a><h1 id="1-DOM概述"><a href="#1-DOM概述" class="headerlink" title="1.DOM概述"></a>1.DOM概述</h1><p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p><p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p><p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p><h1 id="2-节点"><a href="#2-节点" class="headerlink" title="2.节点"></a>2.节点</h1><p>dom的最小组成单位是节点（node）。文档的树形结构 ，就是由各种不同类型的节点组成，每个节点可以看成是树的一片叶子。</p><p>节点的类型由七种：</p><ul><li>Documen：整个文档树的顶层节点</li><li>DocumentType：doctype标签（比如&lt; !DOCTYPE html&gt;）</li><li>Element：网页的各种HTML标签（比如 &lt; body &gt; 、&lt; a&gt;等）</li><li>Attribute：网页元素的属性（比如class=”right”）</li><li>Text：标签之间或标签包含的文本</li><li>Comment：注释</li><li>DocumentFragment：文档的片段<h1 id="3-节点树"><a href="#3-节点树" class="headerlink" title="3.节点树"></a>3.节点树</h1></li></ul><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。</p><p>文档的第一层有两个节点，第一个是文档类型节点（<!doctype html>），第二个是 HTML 网页的顶层容器标签<html>。后者构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p><p>除了根节点，其他节点都有三种层级关系。</p><ul><li>父节点关系（parentNode）：直接的那个上级节点</li><li>子节点关系（childnode）：直接的下级节点</li><li>同级节点关系（sibling）：拥有同一个父节点的节点<h1 id="4-Node接口"><a href="#4-Node接口" class="headerlink" title="4.Node接口"></a>4.Node接口</h1></li></ul><h2 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h2><ul><li>Node.prototype.nodeType<br>nodeType属性返回一个整数值，表示节点的类型</li></ul><pre><code>document.nodeType //9</code></pre><p>上面代码表示documen的文档节点类型是9</p><ul><li>Node.prototype.nodeName</li><li>Node.prototype.nodeValue</li><li>Node.prototype.textContent</li><li>Node.prototype.baseURI</li><li>Node.prototype.ownerDocument</li><li>Node.prototype.nextSibling</li><li>Node.prototype.previousSibling</li><li>Node.prototype.parentNode</li><li>Node.prototype.parentElement</li><li>Node.prototype.firstChild，Node.prototype.lastChild</li><li>Node.prototype.childNodes</li><li>Node.prototype.isConnected<br>（）</li></ul><hr><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js基础查漏补缺</title>
    <link href="/2020/01/14/js/"/>
    <url>/2020/01/14/js/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-js函数"><a href="#1-js函数" class="headerlink" title="1.js函数"></a>1.js函数</h1><a id="more"></a><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h2><p>函数使用function定义，后跟一组参数及函数体 ，语法如下</p><pre><code>function functionName([arg]){}//arg为函数的参数，不是语法</code></pre><p>如</p><pre><code>&lt;script&gt;    function myFun(){        alert(&quot;我是一个函数&quot;);    }    myFun();    &lt;/script&gt;</code></pre><p><strong>函数必须经过调用才能使用</strong></p><h2 id="2-函数的返回值"><a href="#2-函数的返回值" class="headerlink" title="2.函数的返回值"></a>2.函数的返回值</h2><pre><code>function add(num1,num2){    var sum = num1 +num2;    return sum;}console.log(add(2,3));alert(add(23,33));</code></pre><ol><li><p>函数会在执行完return语句之后立即停止或退出</p></li><li><p>return并不一定要有返回值</p><h2 id="3-arguments"><a href="#3-arguments" class="headerlink" title="3.arguments"></a>3.arguments</h2></li><li><p>ECMAScript中的参数在内部用一个数组表示，在函数体内部通过arguements对象来访问这个数组参数。</p></li></ol><p>说明<strong>1.arguements对象只是与数组类似，并不是array的实例</strong></p><h2 id="4-求任意一组数字的平均值"><a href="#4-求任意一组数字的平均值" class="headerlink" title="4.求任意一组数字的平均值"></a>4.求任意一组数字的平均值</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        function getAvg() {            var sum = 0, len = arguments.length, i;            for (i = 0; i &lt; len; i++) {                sum = sum + arguments[i];                //sum = 0+2                //sum = 0+2+4                //sun =0+2+4+52            }            return sum / len;        }        var avg=getAvg(2, 4, 52, 52, 11);        console.log(avg);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="2-js内置对象"><a href="#2-js内置对象" class="headerlink" title="2.js内置对象"></a>2.js内置对象</h1><h2 id="1-js内置对象–数组"><a href="#1-js内置对象–数组" class="headerlink" title="1.js内置对象–数组"></a>1.js内置对象–数组</h2><ol><li>可理解为内置的可以直接调用的</li></ol><h3 id="1-如何创建数组"><a href="#1-如何创建数组" class="headerlink" title="1.如何创建数组"></a>1.如何创建数组</h3><ol><li>使用Array构造函数<br>语法new Array（）</li><li>color.push(“blue”，”yellow”)<br>push方法可以把参数添加到数组的最后<br>unshift可以把参数添加到数组的开头<pre><code>&lt;script&gt;     //push     var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;);     var len = colors.push(&quot;black&quot;, &quot;orange&quot;)     //unshift     var nums = [2, 3, 4, 5, 6];     var size = nums.unshift(1, 0);     console.log(nums);     console.log(colors); &lt;/script&gt;</code></pre></li></ol><ul><li><strong>结果如下</strong><br><img src="https://github.com/jiangjie1105/img-hexo/blob/master/2.png?raw=true" srcset="/img/loading.gif" alt=""></li></ul><h2 id="3-pop删除数组的最后一个元素"><a href="#3-pop删除数组的最后一个元素" class="headerlink" title="3.pop删除数组的最后一个元素"></a>3.pop删除数组的最后一个元素</h2><h2 id="4-shift删除数组的第一个元素"><a href="#4-shift删除数组的第一个元素" class="headerlink" title="4.shift删除数组的第一个元素"></a>4.shift删除数组的第一个元素</h2><ul><li><p><strong>二者返回的不是数组删除后的长度 而是被删除的那个值</strong><br>代码如下：</p><pre><code>&lt;script&gt;     //push     var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;);     var len = colors.push(&quot;black&quot;, &quot;orange&quot;)     //unshift     var nums = [2, 3, 4, 5, 6];     var size = nums.unshift(1, 0);     console.log(nums);     console.log(colors);     //pop     var n =nums.pop();     console.log(nums);     //unshift     var m =colors.shift();     console.log(m); &lt;/script&gt;</code></pre></li></ul><hr><h2 id="5-join把数组转成字符串-字符串拼接用的比较多"><a href="#5-join把数组转成字符串-字符串拼接用的比较多" class="headerlink" title="5.join把数组转成字符串  字符串拼接用的比较多"></a>5.join把数组转成字符串  字符串拼接用的比较多</h2><pre><code>&lt;script&gt;        //join        var nums = [1, 3, 5];        var str = nums.join();        console.log(str);        var words = [&quot;border&quot;, &quot;jiangjie&quot;, &quot;left&quot;];        var wordstr = words.join(&quot;-&quot;);        console.log(wordstr);    &lt;/script&gt;</code></pre><p><img src="https://github.com/jiangjie1105/img-hexo/blob/master/32.png?raw=true" srcset="/img/loading.gif" alt="image"></p><h2 id="6-数组重排序的方法"><a href="#6-数组重排序的方法" class="headerlink" title="6.数组重排序的方法"></a>6.数组重排序的方法</h2><h3 id="1-reverse（）"><a href="#1-reverse（）" class="headerlink" title="1.reverse（）"></a><strong>1.reverse（）</strong></h3><pre><code>var nums = [1, 3, 5];        var str = nums.join();        nums.reverse();        console.log(nums);</code></pre><hr><h2 id="7-sort-用于对数组的元素进行排序"><a href="#7-sort-用于对数组的元素进行排序" class="headerlink" title="7.sort()用于对数组的元素进行排序"></a>7.sort()用于对数组的元素进行排序</h2><ul><li>1.即使数组中的每一项都是数值，sort（）方法比较的也是字符串</li><li>2.sort（）方法可以接收一个比较函数作为参数</li></ul><pre><code>var arr = [1,34,55,7,68,9,80,22];arr.sort(function(a,b){return a-b});console.log(arr);</code></pre><p><img src="https://github.com/jiangjie1105/img-hexo/blob/master/QQ%E6%88%AA%E5%9B%BE20200115084941.png?raw=true" srcset="/img/loading.gif" alt=""></p><p>//sort倒序图片</p><h2 id="8-concat（）-连接数组"><a href="#8-concat（）-连接数组" class="headerlink" title="8.concat（） 连接数组"></a>8.concat（） 连接数组</h2><p>b.concat();</p><h2 id="9-slice（）"><a href="#9-slice（）" class="headerlink" title="9.slice（）"></a>9.slice（）</h2><p>语法：arrayObject.slice（start,end）</p><p><img src="https://github.com/jiangjie1105/img-hexo/blob/master/QQ%E6%88%AA%E5%9B%BE20200115091508.png?raw=true" srcset="/img/loading.gif" alt=""></p><ul><li>掌握使用splice（）方法删除数组项</li></ul><ol><li><p>arrObject.<strong>splice</strong>(index,count)<br>功能：删除从index处开始的零个或多个元素</p></li><li><p>返回值：含有被删除的元素的数组。</p></li><li><p>说明：count是要删除的项目输血量 如果设置为零，则不会删除项目，如果不设置，则删除从index开始的所有值</p></li></ol><pre><code>//删除        var delArr = arr.splice(2, 0);        console.log(arr);//输出六个值        console.log(delArr);//输出零个值</code></pre><hr><ul><li>掌握使用splice（）方法插入数组项</li></ul><pre><code> //插入        var insertArr = arr.splice(2, 3, &quot;m&quot;, &quot;n&quot;)        console.log(arr);//输出六个值        console.log(insertArr);//输出零个值</code></pre><hr><ul><li>掌握使用splice（）方法替换数组项</li></ul><pre><code>var replaceArr = arr.splice(1,2,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;)        console.log(replaceArr);</code></pre><hr><h2 id="10-indexOf"><a href="#10-indexOf" class="headerlink" title="10.indexOf"></a>10.indexOf</h2><ul><li>语法：判断元素在数组中出现的位置，从数组的开头开始查找，<br>返回值：查找的项在数组中的位置</li></ul><p>没有找到的情况下返回-1。</p><pre><code>var nums = [1,2,3,4,23,2,35,23]；var pos = nums.indexOf(3,x)；//这个x指从数组中索引为几开始算，若不填则为0</code></pre><h2 id="11-lastIndexOf"><a href="#11-lastIndexOf" class="headerlink" title="11.lastIndexOf()"></a>11.lastIndexOf()</h2><ul><li>功能：从数组的末尾开始向前查找<br>返回值：查找的项在数组中的位置</li></ul><pre><code>var nums = [1,2,3,4,23,2,35,23]；console.log(pos);//封装一个方法实现indexOf的功能</code></pre><pre><code>&lt;script&gt;    var nums = [1, 3, 4, 5, 7, 8, 45, 43, 22, 11, 35];    function ArrayIndexOf(arr, value) {        //检测value在arr中出现的位置        for (var i = 0; i &lt; arr.length; i++) {            if (arr[i] === value) {                return i;            }        }        return -1;    }    var pos=ArrayIndexOf(nums,43);    console.log(pos);//输出为7&lt;/script&gt;</code></pre><h2 id="2-内置对象–String"><a href="#2-内置对象–String" class="headerlink" title="2.内置对象–String"></a>2.内置对象–String</h2><ol><li>charcodeat  或者字符串中的字母</li></ol><p><strong>2. indexOf（）</strong></p><p>语法：stringObject.indexOf(“o”)<br>功能：从一个字符串中搜索给定的字符串位置，返回字符串的位置。<br>返回值：数值<br>说明：如果没有找到该字符串，则返回-1</p><pre><code>&lt;script&gt;    var email = &quot;102130103@qq.com&quot;;    console.log(email.indexOf(&quot;q&quot;));    &lt;/script&gt;//输出10。（检测第一次出现的位置）</code></pre><p><strong>2. lastindexOf（）</strong><br>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1.</p><p><strong>注意，以上两种方法不能来搜索nan的位置</strong></p><h2 id="3-slice"><a href="#3-slice" class="headerlink" title="3. slice()"></a>3. slice()</h2><p>语法：<br>stringObject.slice(start,end)<br>功能：截取子字符串<br>参数说明：1.start：必须，指定字符串开始位置</p><p>2.end：可选，表示字符串到哪里结束，end本身不再截取范围之内，省略时截取至字符串的末尾，<br>最后一个参数时 截取到末尾。</p><p>3.当参数为负数时，会将传入的负值与字符串的长度相加</p><h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p>语法与slice一致，不同的是</p><h2 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h2><h2 id="字符串的综合应用"><a href="#字符串的综合应用" class="headerlink" title="字符串的综合应用"></a><strong>字符串的综合应用</strong></h2><hr><p>获取扩展名</p><pre><code>&lt;script&gt;        var url = &quot;http://www.hao123.com/index.txt&quot;;        function getFileFormat(url) {            //获取. 在url中的位置            var pos = url.lastIndexOf(&quot;.&quot;);            return url.substr(pos);        }        var formatName = getFileFormat(url);        var picFormat = getFileFormat(&quot;35672153.png&quot;);        console.log(formatName);        console.log(picFormat);    &lt;/script&gt;</code></pre><h2 id="split（）"><a href="#split（）" class="headerlink" title="split（）"></a>split（）</h2><p>语法：stringObject.split(separator)</p><p>功能：<br>把一个字符串分割成字符串数组</p><p>返回值：Array。说明：</p><p>separator：必须，分隔符</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型-检测</title>
    <link href="/2020/01/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%A3%80%E6%B5%8B/"/>
    <url>/2020/01/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-typeof是否能正确判断类型"><a href="#1-typeof是否能正确判断类型" class="headerlink" title="1.typeof是否能正确判断类型"></a><strong>1.typeof是否能正确判断类型</strong></h2><a id="more"></a><p>对于原始类型，除了null都可以调用typeof显示正确的类型。</p><pre><code>typeof 1 // &#39;number&#39;typeof &#39;1&#39; // &#39;string&#39;typeof undefined // &#39;undefined&#39;typeof true // &#39;boolean&#39;typeof Symbol() // &#39;symbol&#39;</code></pre><p>但对于引用数据类型，除了函数之外，都会显示“object“</p><pre><code>typeof [] // &#39;object&#39;typeof {} // &#39;object&#39;typeof console.log // &#39;function&#39;</code></pre><p>所以采用typeof判断数据类型是不合适的，而采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原形链中，判断永远为true</p><pre><code>const Person = function() {}const p1 = new Person()p1 instanceof Person // truevar str1 = &#39;hello world&#39;str1 instanceof String // falsevar str2 = new String(&#39;hello world&#39;)str2 instanceof String // true</code></pre><h2 id="2-instanceof能否判断基本数据类型？"><a href="#2-instanceof能否判断基本数据类型？" class="headerlink" title="2.instanceof能否判断基本数据类型？"></a><strong>2.instanceof能否判断基本数据类型？</strong></h2><ul><li>答 可以，例如</li></ul><pre><code>class PrimitiveNumber {  static [Symbol.hasInstance](x) {    return typeof x === &#39;number&#39;  }}console.log(111 instanceof PrimitiveNumber) // true</code></pre><p>(上面的代码暂时看不懂，回头来解决)</p><h2 id="3-手动实现一下instanceof"><a href="#3-手动实现一下instanceof" class="headerlink" title="3.手动实现一下instanceof?"></a><strong>3.手动实现一下instanceof?</strong></h2><ul><li><strong>核心原型链的向上查找</strong><h2 id="4-Object-is和-的区别"><a href="#4-Object-is和-的区别" class="headerlink" title="4.Object.is和===的区别"></a><strong>4.Object.is和===的区别</strong></h2>(占坑 稍后填<br>)</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-复杂度分析（下）</title>
    <link href="/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天学习 四个复杂度分析</p><a id="more"></a><h2 id="1-最好情况时间复杂度"><a href="#1-最好情况时间复杂度" class="headerlink" title="1.最好情况时间复杂度"></a>1.最好情况时间复杂度</h2><p>看下面的代码</p><pre><code>// n 表示数组 array 的长度int find(int[] array, int n, int x) { int i = 0; int pos = -1; for (; i &lt; n; ++i) { if (array[i] == x) pos = i; } return pos;}</code></pre><p>上面代码的主要功能是，在一个无序数组（array）中<br>，查找变量x出现的位置，如果没有找到，就返回-1，这段代码的时间复杂度是0（n）<br>最好情况复杂度就是<strong>在最理想的情况下执行这段代码的时间复杂度</strong><br>比如想要查找的变量x正好是数组的第一个元素，这时对应的复杂度就是最好情况时间复杂度。</p><h2 id="2-最坏情况时间复杂度"><a href="#2-最坏情况时间复杂度" class="headerlink" title="2.最坏情况时间复杂度"></a>2.最坏情况时间复杂度</h2><p>同理，在最糟糕的情况下 如果我想要查找的元素变量x，在数组中没有，则需要把整个数组遍历一遍，这种比较糟糕的情况下，对应的时间复杂度就是最坏时间复杂度。</p><h2 id="3-平均情况时间复杂度"><a href="#3-平均情况时间复杂度" class="headerlink" title="3.平均情况时间复杂度"></a>3.平均情况时间复杂度</h2><p>在一般的代码中 最好情况复杂度和最坏情况复杂度对应的都是比较极端的情况，并不常见，所以需要引入另一个概念，<strong>平均时间复杂度</strong></p><ul><li>举例<br>如上面的代码，<br>要查找的变量x在数组中的位置有n+1种情况，<strong>从0索引到n-1索引或者不在数组中</strong>，这种情况，查找需要遍历的元素个数累加起来，再除以<strong>n+1</strong> 就可以得到需要遍历的元素个数平均值，即<br><img src="https://github.com/jiangjie1105/img-hexo/blob/master/1.png?raw=true" srcset="/img/loading.gif" alt="image"></li></ul><p>这个值就是概率论中的加权平均值，也叫期望值，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong></p><h2 id="4-均摊时间复杂度"><a href="#4-均摊时间复杂度" class="headerlink" title="4.均摊时间复杂度"></a>4.均摊时间复杂度</h2><p>（未填坑）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型--概念</title>
    <link href="/2020/01/13/js%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    <url>/2020/01/13/js%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-js原始数据类型"><a href="#1-js原始数据类型" class="headerlink" title="1.js原始数据类型"></a>1.js原始数据类型</h2><a id="more"></a><p>在js中 有七种原始数据类型 </p><ul><li>boolean</li><li>null</li><li>symbol</li><li>string</li><li>number</li><li>undefined</li><li>bigint</li></ul><h2 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h2><ul><li>对象object(包含普通对象-object 数组对象-array，正则对象-regexp，日期对象date，数学函数-math 函数对象-fuction)<h3 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h3></li></ul><ol><li>基本数据类型 保存在<strong>栈</strong>内存中，因为这些类型在内存中分别有固定的大小，通过按值来访问</li><li>引用数据类型 保存在<strong>堆</strong>内存中，因为这些值大小不固定，因此不能把他们放在栈内存中，但内存地址是有固定大小的，所以保存在堆内存中，在栈中存放的内存只是对该对象的访问地址，当查询引用类型的变量时 先从<strong>栈中读取内存地址然后再通过地址找到堆中的值</strong>对于这种 我们叫做按引用访问。</li></ol><p><img src="http://resource.muyiy.cn/image/2019-07-24-060214.png" srcset="/img/loading.gif" alt="栈内存和堆内存"></p><p>下面看几个问题</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1."></a>问题1.</h3><pre><code>var a = 20;var b = a;b = 30;//a值为多少？？</code></pre><p>a，b都是基本数据类型 ，他们的值存在栈中，ab分别有自己的栈空间，所以修改了b 的值以后，a的值并不会发生变化</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><pre><code>var a = {&quot;name: 刘德华&quot;}var b = a;b.name = {&quot;张学友&quot;} </code></pre><ul><li>a,b 此时都是引用数据类型栈内存中存放地址指向对内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象 所以修改b.name的值后，相应的a.name也发生了改变<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><pre><code>var a = { name: &#39;前端开发&#39; }var b = a;a = null;//这时b值是多少</code></pre></li><li>首先null是基本数据类型，a = null 之后只是把a存储在栈内存中的地址改成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。</li></ul><hr><h2 id="3-null是对象吗，为什么？"><a href="#3-null是对象吗，为什么？" class="headerlink" title="3.null是对象吗，为什么？"></a><strong>3.null是对象吗，为什么？</strong></h2><ul><li>null不是对象 虽然typeof null会输出object 但是这时js存在的一个bug 再js最初版本是32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表的是对象然而null表示全零，所以它错误的判断为object。</li></ul><hr><h2 id="4-toString（）为什么可以调用？"><a href="#4-toString（）为什么可以调用？" class="headerlink" title="4.toString（）为什么可以调用？"></a><strong>4.toString（）为什么可以调用？</strong></h2><p>请看下面代码</p><pre><code>var s = new Object(&#39;1&#39;);s.tostring();s = null;</code></pre><p>第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</p><p>第二步: 调用实例方法。</p><p>第三步: 执行完方法立即销毁这个实例。</p><p>整个过程中体现了<strong>基本包装类型</strong>的性质，而基本包装类型是属于基本数据类型 包括boolean，number，string。（红宝书p118）</p><hr><h2 id="5-0-1-0-2为什么不等于0-3？"><a href="#5-0-1-0-2为什么不等于0-3？" class="headerlink" title="5. 0.1+0.2为什么不等于0.3？"></a><strong>5. 0.1+0.2为什么不等于0.3？</strong></h2><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。<br><img src="https://github.com/jiangjie1105/img-hexo/blob/master/0.1+0.2.png?raw=true" srcset="/img/loading.gif" alt="image"></p><hr><h2 id="5-如何理解bignit？"><a href="#5-如何理解bignit？" class="headerlink" title="5.如何理解bignit？"></a><strong>5.如何理解bignit？</strong></h2><ul><li>我所理解的bigint，简单来说就是一种新的数据类型 目前还没有广泛使用 即整数值大于number数据类型支持的范围时，可以使用bigint<h3 id="1-bigint的创建"><a href="#1-bigint的创建" class="headerlink" title="1.bigint的创建"></a><strong>1.bigint的创建</strong></h3></li></ul><ol><li>可以在数字末尾加n<pre><code>console.log(9048394789734987n)</code></pre></li><li>可以用bigint（）构造函数，<pre><code>BigInt(&quot;3432423423242342&quot;);//3432423423242342</code></pre></li><li>简单使用如下<br>```<br>10n + 20n;    // → 30n<br>10n - 20n;    // → -10n    </li></ol><p>+10n;         // → TypeError: Cannot convert a BigInt value to a number<br>-10n;         // → -10n<br>10n * 20n;    // → 200n<br>20n / 10n;    // → 2n<br>23n % 10n;    // → 3n<br>10n ** 3n;    // → 1000n</p><p>```</p><h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ol><li><p>BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。</p></li><li><p>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。</p></li><li><p>不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。</p></li><li><p>当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。</p></li><li><p>元素都为BigInt的数组可以进行sort。</p></li><li><p>BigInt可以正常地进行位运算，如|、&amp;、&lt;&lt;、&gt;&gt;和^</p><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a><strong>浏览器兼容性</strong></h2></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/22/16df110a69c0ae17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-复杂度分析(上)</title>
    <link href="/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>如下代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal (int n) &#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int i &#x3D; 1;</span><br><span class="line">    int j &#x3D; 1;</span><br><span class="line">    for (;i &lt; &#x3D; n ; i++)&#123;</span><br><span class="line">        j &#x3D; 1;</span><br><span class="line">        for (; j&lt;&#x3D; n; ++j) &#123;</span><br><span class="line">            sum &#x3D; sum + i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码二三四行都需要一个unit_time 执行时间，五六行循环执行了n遍，需要2n×unit_time执行时间 第七八行执行了n²次 所以总时间等于(2n²＋2n＋3)*unit_time</p><h2 id="1-大o复杂度表示法"><a href="#1-大o复杂度表示法" class="headerlink" title="1.大o复杂度表示法"></a>1.大o复杂度表示法</h2><h3 id="读数据–运算–写数据"><a href="#读数据–运算–写数据" class="headerlink" title="读数据–运算–写数据"></a>读数据–运算–写数据</h3><p>从cpu角度来讲 每一行都执行着类似操作 大o时间复杂度实际上不是代码的具体执行时间 而是表示代码执行时间随数据规模增长的变化趋势 所以也叫 <strong>渐进时间复杂度</strong> 也称<strong>时间复杂度</strong></p><h2 id="2-时间复杂度分析"><a href="#2-时间复杂度分析" class="headerlink" title="2.时间复杂度分析"></a>2.时间复杂度分析</h2><ol><li><p>只关注时间复杂度次数最多的一段代码，分析一段代码的时间复杂度时，也只关注循环执行次数最多的那一段代码就行了。</p></li><li><p>总的时间复杂度就等于量级最大的那段代码的时间复杂度</p></li><li><p>乘法法则：嵌套的代码的复杂度等于嵌套内外代码的复杂度的乘积  如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 <strong>T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n))</strong>.</p></li></ol><ul><li>非多项式量级</li></ul><ol><li>：O(2 ) 和 O(n!) </li></ol><p>当数据规模很大时这两者算法执行时间会急剧增加，求解问题时间会无限增长 所以很低效 。</p><ul><li>多项式量级</li></ul><ol><li>0（1）</li></ol><p>0（1）只是时间复杂度的一种表示方法，不是执行了一行代码所以 只要语句中不存在循环语句，递归语句，即使有成千上万行代码 时间复杂度都是0（1）.</p><ol start="2"><li><p>O(logn)、O(nlogn)<br>如下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 1 ;</span><br><span class="line">while (i &lt;&#x3D; n) &#123;</span><br><span class="line">    i &#x3D; i * 2；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中实际上就是i的值开始时是1，之后每次循环都乘二 相当于2的x次方等于n ，所以时间复杂度为以2为底log n, <strong>因为对数之间可以互相转换 所以采用大0标记复杂度的时候 可以忽略系数，即 O(Cf(n)) = O(f(n))。</strong></p><ul><li>o（ologn）</li></ul><p>如果一段代码时间复杂度为O（logn）那么循环n次就是o（nlogn）</p><ol start="3"><li>o（m+n），o（m*n）</li></ol><p>代码的复杂度<strong>由两个数据规模</strong>来决定 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">    int sum_1 &#x3D; 0; </span><br><span class="line">    int i &#x3D; 1; </span><br><span class="line">    for (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 &#x3D; sum_1 + i;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int sum_2 &#x3D; 0; </span><br><span class="line">    int j &#x3D; 1;  </span><br><span class="line">    for (; j &lt; n; ++j) &#123;</span><br><span class="line">        sum_2 &#x3D; sum_2 + j;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  return sum_1 + sum_2; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的代码中 m和n是两个数据规模 我们无法评估谁的量级大所以在表示 时间复杂度时就不能用加法准则，所以上面的代码时间复杂的就是0（m+n）<br>所以针对上面的情况，加法规则就不正确了，<br>需要改为<strong>T1(m)+T2(n)=o(f(m) + g(n))</strong> 乘法规则继续有效。</p></li></ol><ul><li>空间复杂度分析 </li></ul><p>空间复杂度的全称就是<strong>渐进空间复杂度表示算法的存储空间与数据规模之间的增长关系</strong>。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p><strong>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，越高阶复杂度的算法，执行效率越低。从低阶到高阶的有：o(1),o(logn),o(n),o(nlogn),o(n²)</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/02/14/hello-world/"/>
    <url>/2019/02/14/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
