<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js基础查漏补缺</title>
    <link href="/2020/01/14/js/"/>
    <url>/2020/01/14/js/</url>
    
    <content type="html"><![CDATA[<h1 id="1-js函数"><a href="#1-js函数" class="headerlink" title="1.js函数"></a>1.js函数</h1><a id="more"></a><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h2><p>函数使用function定义，后跟一组参数及函数体 ，语法如下</p><pre><code>function functionName([arg]){}//arg为函数的参数，不是语法</code></pre><p>如</p><pre><code>&lt;script&gt;    function myFun(){        alert(&quot;我是一个函数&quot;);    }    myFun();    &lt;/script&gt;</code></pre><p><strong>函数必须经过调用才能使用</strong></p><h2 id="2-函数的返回值"><a href="#2-函数的返回值" class="headerlink" title="2.函数的返回值"></a>2.函数的返回值</h2><pre><code>function add(num1,num2){    var sum = num1 +num2;    return sum;}console.log(add(2,3));alert(add(23,33));</code></pre><ol><li><p>函数会在执行完return语句之后立即停止或退出</p></li><li><p>return并不一定要有返回值</p><h2 id="3-arguments"><a href="#3-arguments" class="headerlink" title="3.arguments"></a>3.arguments</h2></li><li><p>ECMAScript中的参数在内部用一个数组表示，在函数体内部通过arguements对象来访问这个数组参数。</p></li></ol><p>说明<strong>1.arguements对象只是与数组类似，并不是array的实例</strong></p><h2 id="4-求任意一组数字的平均值"><a href="#4-求任意一组数字的平均值" class="headerlink" title="4.求任意一组数字的平均值"></a>4.求任意一组数字的平均值</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        function getAvg() {            var sum = 0, len = arguments.length, i;            for (i = 0; i &lt; len; i++) {                sum = sum + arguments[i];                //sum = 0+2                //sum = 0+2+4                //sun =0+2+4+52            }            return sum / len;        }        var avg=getAvg(2, 4, 52, 52, 11);        console.log(avg);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="2-js内置对象"><a href="#2-js内置对象" class="headerlink" title="2.js内置对象"></a>2.js内置对象</h1><h2 id="1-js内置对象–数组"><a href="#1-js内置对象–数组" class="headerlink" title="1.js内置对象–数组"></a>1.js内置对象–数组</h2><ol><li>可理解为内置的可以直接调用的</li></ol><h3 id="1-如何创建数组"><a href="#1-如何创建数组" class="headerlink" title="1.如何创建数组"></a>1.如何创建数组</h3><ol><li>使用Array构造函数<br>语法new Array（）</li><li>color.push(“blue”，”yellow”)<br>push方法可以把参数添加到数组的最后<br>unshift可以把参数添加到数组的开头<pre><code>&lt;script&gt;     //push     var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;);     var len = colors.push(&quot;black&quot;, &quot;orange&quot;)     //unshift     var nums = [2, 3, 4, 5, 6];     var size = nums.unshift(1, 0);     console.log(nums);     console.log(colors); &lt;/script&gt;</code></pre></li></ol><ul><li><strong>结果如下</strong><br><img src="https://github.com/jiangjie1105/img-hexo/blob/master/2.png?raw=true" srcset="/img/loading.gif" alt=""></li></ul><h2 id="3-pop删除数组的最后一个元素"><a href="#3-pop删除数组的最后一个元素" class="headerlink" title="3.pop删除数组的最后一个元素"></a>3.pop删除数组的最后一个元素</h2><h2 id="4-shift删除数组的第一个元素"><a href="#4-shift删除数组的第一个元素" class="headerlink" title="4.shift删除数组的第一个元素"></a>4.shift删除数组的第一个元素</h2><ul><li><p><strong>二者返回的不是数组删除后的长度 而是被删除的那个值</strong><br>代码如下：</p><pre><code>&lt;script&gt;     //push     var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;);     var len = colors.push(&quot;black&quot;, &quot;orange&quot;)     //unshift     var nums = [2, 3, 4, 5, 6];     var size = nums.unshift(1, 0);     console.log(nums);     console.log(colors);     //pop     var n =nums.pop();     console.log(nums);     //unshift     var m =colors.shift();     console.log(m); &lt;/script&gt;</code></pre></li></ul><hr><h2 id="5-join把数组转成字符串-字符串拼接用的比较多"><a href="#5-join把数组转成字符串-字符串拼接用的比较多" class="headerlink" title="5.join把数组转成字符串  字符串拼接用的比较多"></a>5.join把数组转成字符串  字符串拼接用的比较多</h2><pre><code>&lt;script&gt;        //join        var nums = [1, 3, 5];        var str = nums.join();        console.log(str);        var words = [&quot;border&quot;, &quot;jiangjie&quot;, &quot;left&quot;];        var wordstr = words.join(&quot;-&quot;);        console.log(wordstr);    &lt;/script&gt;</code></pre><p><img src="https://github.com/jiangjie1105/img-hexo/blob/master/32.png?raw=true" srcset="/img/loading.gif" alt="image"></p><h2 id="6-数组重排序的方法"><a href="#6-数组重排序的方法" class="headerlink" title="6.数组重排序的方法"></a>6.数组重排序的方法</h2><h3 id="1-reverse（）"><a href="#1-reverse（）" class="headerlink" title="1.reverse（）"></a><strong>1.reverse（）</strong></h3><pre><code>var nums = [1, 3, 5];        var str = nums.join();        nums.reverse();        console.log(nums);</code></pre><hr><h2 id="7-sort-用于对数组的元素进行排序"><a href="#7-sort-用于对数组的元素进行排序" class="headerlink" title="7.sort()用于对数组的元素进行排序"></a>7.sort()用于对数组的元素进行排序</h2><ul><li>1.即使数组中的每一项都是数值，sort（）方法比较的也是字符串</li><li>2.sort（）方法可以接收一个比较函数作为参数</li></ul><pre><code>var arr = [1,34,55,7,68,9,80,22];arr.sort(function(a,b){return a-b});console.log(arr);</code></pre><p><img src="https://github.com/jiangjie1105/img-hexo/blob/master/QQ%E6%88%AA%E5%9B%BE20200115084941.png?raw=true" srcset="/img/loading.gif" alt=""></p><p>//sort倒序图片</p><h2 id="8-concat（）-连接数组"><a href="#8-concat（）-连接数组" class="headerlink" title="8.concat（） 连接数组"></a>8.concat（） 连接数组</h2><p>b.concat();</p><h2 id="9-slice（）"><a href="#9-slice（）" class="headerlink" title="9.slice（）"></a>9.slice（）</h2><p>语法：arrayObject.slice（start,end）</p><p><img src="https://github.com/jiangjie1105/img-hexo/blob/master/QQ%E6%88%AA%E5%9B%BE20200115091508.png?raw=true" srcset="/img/loading.gif" alt=""></p><ul><li>掌握使用splice（）方法删除数组项</li></ul><ol><li><p>arrObject.<strong>splice</strong>(index,count)<br>功能：删除从index处开始的零个或多个元素</p></li><li><p>返回值：含有被删除的元素的数组。</p></li><li><p>说明：count是要删除的项目输血量 如果设置为零，则不会删除项目，如果不设置，则删除从index开始的所有值</p></li></ol><pre><code>//删除        var delArr = arr.splice(2, 0);        console.log(arr);//输出六个值        console.log(delArr);//输出零个值</code></pre><hr><ul><li>掌握使用splice（）方法插入数组项</li></ul><pre><code> //插入        var insertArr = arr.splice(2, 3, &quot;m&quot;, &quot;n&quot;)        console.log(arr);//输出六个值        console.log(insertArr);//输出零个值</code></pre><hr><ul><li>掌握使用splice（）方法替换数组项</li></ul><pre><code>var replaceArr = arr.splice(1,2,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;)        console.log(replaceArr);</code></pre><hr><h2 id="10-indexOf"><a href="#10-indexOf" class="headerlink" title="10.indexOf"></a>10.indexOf</h2><ul><li>语法：判断元素在数组中出现的位置，从数组的开头开始查找，<br>返回值：查找的项在数组中的位置</li></ul><p>没有找到的情况下返回-1。</p><pre><code>var nums = [1,2,3,4,23,2,35,23]；var pos = nums.indexOf(3,x)；//这个x指从数组中索引为几开始算，若不填则为0</code></pre><h2 id="11-lastIndexOf"><a href="#11-lastIndexOf" class="headerlink" title="11.lastIndexOf()"></a>11.lastIndexOf()</h2><ul><li>功能：从数组的末尾开始向前查找<br>返回值：查找的项在数组中的位置</li></ul><pre><code>var nums = [1,2,3,4,23,2,35,23]；console.log(pos);//封装一个方法实现indexOf的功能</code></pre><pre><code>&lt;script&gt;    var nums = [1, 3, 4, 5, 7, 8, 45, 43, 22, 11, 35];    function ArrayIndexOf(arr, value) {        //检测value在arr中出现的位置        for (var i = 0; i &lt; arr.length; i++) {            if (arr[i] === value) {                return i;            }        }        return -1;    }    var pos=ArrayIndexOf(nums,43);    console.log(pos);//输出为7&lt;/script&gt;</code></pre><h2 id="2-内置对象–String"><a href="#2-内置对象–String" class="headerlink" title="2.内置对象–String"></a>2.内置对象–String</h2><ol><li>charcodeat  或者字符串中的字母</li></ol><p><strong>2. indexOf（）</strong></p><p>语法：stringObject.indexOf(“o”)<br>功能：从一个字符串中搜索给定的字符串位置，返回字符串的位置。<br>返回值：数值<br>说明：如果没有找到该字符串，则返回-1</p><pre><code>&lt;script&gt;    var email = &quot;102130103@qq.com&quot;;    console.log(email.indexOf(&quot;q&quot;));    &lt;/script&gt;//输出10。（检测第一次出现的位置）</code></pre><p><strong>2. lastindexOf（）</strong><br>从字符串最后开始检测</p><h2 id="3-slice"><a href="#3-slice" class="headerlink" title="3. slice()"></a>3. slice()</h2><p>语法：<br>stringObject.slice(start,end)<br>功能：截取子字符串<br>参数说明：1.start：必须，指定字符串开始位置</p><p>2.end：可选，表示字符串到哪里结束，end本身不再截取范围之内，省略时截取至字符串的末尾，<br>最后一个参数时 截取到末尾。</p><p>3.当参数为负数时，会将传入的负值与字符串的长度相加</p><h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p>语法与slice一致，不同的是</p><h2 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h2><h2 id="字符串的综合应用"><a href="#字符串的综合应用" class="headerlink" title="字符串的综合应用"></a><strong>字符串的综合应用</strong></h2><hr><p>获取扩展名</p><pre><code>&lt;script&gt;        var url = &quot;http://www.hao123.com/index.txt&quot;;        function getFileFormat(url) {            //获取. 在url中的位置            var pos = url.lastIndexOf(&quot;.&quot;);            return url.substr(pos);        }        var formatName = getFileFormat(url);        var picFormat = getFileFormat(&quot;35672153.png&quot;);        console.log(formatName);        console.log(picFormat);    &lt;/script&gt;</code></pre><h2 id="split（）"><a href="#split（）" class="headerlink" title="split（）"></a>split（）</h2><p>语法：stringObject.split(separator)</p><p>功能：<br>把一个字符串分割成字符串数组</p><p>返回值：Array。说明：</p><p>separator：必须，分隔符</p><hr><h1 id="3-jsDOM基础"><a href="#3-jsDOM基础" class="headerlink" title="3.jsDOM基础"></a>3.jsDOM基础</h1><h1 id="4-jsDom事件"><a href="#4-jsDom事件" class="headerlink" title="4.jsDom事件"></a>4.jsDom事件</h1><h1 id="5-jsBom对象"><a href="#5-jsBom对象" class="headerlink" title="5.jsBom对象"></a>5.jsBom对象</h1><h1 id="6-js实现轮播特效"><a href="#6-js实现轮播特效" class="headerlink" title="6.js实现轮播特效"></a>6.js实现轮播特效</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型-检测</title>
    <link href="/2020/01/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%A3%80%E6%B5%8B/"/>
    <url>/2020/01/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-typeof是否能正确判断类型"><a href="#1-typeof是否能正确判断类型" class="headerlink" title="1.typeof是否能正确判断类型"></a><strong>1.typeof是否能正确判断类型</strong></h2><a id="more"></a><p>对于原始类型，除了null都可以调用typeof显示正确的类型。</p><pre><code>typeof 1 // &#39;number&#39;typeof &#39;1&#39; // &#39;string&#39;typeof undefined // &#39;undefined&#39;typeof true // &#39;boolean&#39;typeof Symbol() // &#39;symbol&#39;</code></pre><p>但对于引用数据类型，除了函数之外，都会显示“object“</p><pre><code>typeof [] // &#39;object&#39;typeof {} // &#39;object&#39;typeof console.log // &#39;function&#39;</code></pre><p>所以采用typeof判断数据类型是不合适的，而采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原形链中，判断永远为true</p><pre><code>const Person = function() {}const p1 = new Person()p1 instanceof Person // truevar str1 = &#39;hello world&#39;str1 instanceof String // falsevar str2 = new String(&#39;hello world&#39;)str2 instanceof String // true</code></pre><h2 id="2-instanceof能否判断基本数据类型？"><a href="#2-instanceof能否判断基本数据类型？" class="headerlink" title="2.instanceof能否判断基本数据类型？"></a><strong>2.instanceof能否判断基本数据类型？</strong></h2><ul><li>答 可以，例如</li></ul><pre><code>class PrimitiveNumber {  static [Symbol.hasInstance](x) {    return typeof x === &#39;number&#39;  }}console.log(111 instanceof PrimitiveNumber) // true</code></pre><p>(上面的代码暂时看不懂，回头来解决)</p><h2 id="3-手动实现一下instanceof"><a href="#3-手动实现一下instanceof" class="headerlink" title="3.手动实现一下instanceof?"></a><strong>3.手动实现一下instanceof?</strong></h2><ul><li><strong>核心原型链的向上查找</strong><h2 id="4-Object-is和-的区别"><a href="#4-Object-is和-的区别" class="headerlink" title="4.Object.is和===的区别"></a><strong>4.Object.is和===的区别</strong></h2>(占坑 稍后填<br>)</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-复杂度分析（下）</title>
    <link href="/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天学习 四个复杂度分析</p><a id="more"></a><h2 id="1-最好情况时间复杂度"><a href="#1-最好情况时间复杂度" class="headerlink" title="1.最好情况时间复杂度"></a>1.最好情况时间复杂度</h2><p>看下面的代码</p><pre><code>// n 表示数组 array 的长度int find(int[] array, int n, int x) { int i = 0; int pos = -1; for (; i &lt; n; ++i) { if (array[i] == x) pos = i; } return pos;}</code></pre><p>上面代码的主要功能是，在一个无序数组（array）中<br>，查找变量x出现的位置，如果没有找到，就返回-1，这段代码的时间复杂度是0（n）<br>最好情况复杂度就是<strong>在最理想的情况下执行这段代码的时间复杂度</strong><br>比如想要查找的变量x正好是数组的第一个元素，这时对应的复杂度就是最好情况时间复杂度。</p><h2 id="2-最坏情况时间复杂度"><a href="#2-最坏情况时间复杂度" class="headerlink" title="2.最坏情况时间复杂度"></a>2.最坏情况时间复杂度</h2><p>同理，在最糟糕的情况下 如果我想要查找的元素变量x，在数组中没有，则需要把整个数组遍历一遍，这种比较糟糕的情况下，对应的时间复杂度就是最坏时间复杂度。</p><h2 id="3-平均情况时间复杂度"><a href="#3-平均情况时间复杂度" class="headerlink" title="3.平均情况时间复杂度"></a>3.平均情况时间复杂度</h2><p>在一般的代码中 最好情况复杂度和最坏情况复杂度对应的都是比较极端的情况，并不常见，所以需要引入另一个概念，<strong>平均时间复杂度</strong></p><ul><li>举例<br>如上面的代码，<br>要查找的变量x在数组中的位置有n+1种情况，<strong>从0索引到n-1索引或者不在数组中</strong>，这种情况，查找需要遍历的元素个数累加起来，再除以<strong>n+1</strong> 就可以得到需要遍历的元素个数平均值，即<br><img src="https://github.com/jiangjie1105/img-hexo/blob/master/1.png?raw=true" srcset="/img/loading.gif" alt="image"></li></ul><p>这个值就是概率论中的加权平均值，也叫期望值，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong></p><h2 id="4-均摊时间复杂度"><a href="#4-均摊时间复杂度" class="headerlink" title="4.均摊时间复杂度"></a>4.均摊时间复杂度</h2><p>（未填坑）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型--概念</title>
    <link href="/2020/01/13/js%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    <url>/2020/01/13/js%E9%97%AE%E9%A2%98%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-js原始数据类型"><a href="#1-js原始数据类型" class="headerlink" title="1.js原始数据类型"></a>1.js原始数据类型</h2><a id="more"></a><p>在js中 有七种原始数据类型 </p><ul><li>boolean</li><li>null</li><li>symbol</li><li>string</li><li>number</li><li>undefined</li><li>bigint</li></ul><h2 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h2><ul><li>对象object(包含普通对象-object 数组对象-array，正则对象-regexp，日期对象date，数学函数-math 函数对象-fuction)<h3 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h3></li></ul><ol><li>基本数据类型 保存在<strong>栈</strong>内存中，因为这些类型在内存中分别有固定的大小，通过按值来访问</li><li>引用数据类型 保存在<strong>堆</strong>内存中，因为这些值大小不固定，因此不能把他们放在栈内存中，但内存地址是有固定大小的，所以保存在堆内存中，在栈中存放的内存只是对该对象的访问地址，当查询引用类型的变量时 先从<strong>栈中读取内存地址然后再通过地址找到堆中的值</strong>对于这种 我们叫做按引用访问。</li></ol><p><img src="http://resource.muyiy.cn/image/2019-07-24-060214.png" srcset="/img/loading.gif" alt="栈内存和堆内存"></p><p>下面看几个问题</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1."></a>问题1.</h3><pre><code>var a = 20;var b = a;b = 30;//a值为多少？？</code></pre><p>a，b都是基本数据类型 ，他们的值存在栈中，ab分别有自己的栈空间，所以修改了b 的值以后，a的值并不会发生变化</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><pre><code>var a = {&quot;name: 刘德华&quot;}var b = a;b.name = {&quot;张学友&quot;} </code></pre><ul><li>a,b 此时都是引用数据类型栈内存中存放地址指向对内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象 所以修改b.name的值后，相应的a.name也发生了改变<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><pre><code>var a = { name: &#39;前端开发&#39; }var b = a;a = null;//这时b值是多少</code></pre></li><li>首先null是基本数据类型，a = null 之后只是把a存储在栈内存中的地址改成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。</li></ul><hr><h2 id="3-null是对象吗，为什么？"><a href="#3-null是对象吗，为什么？" class="headerlink" title="3.null是对象吗，为什么？"></a><strong>3.null是对象吗，为什么？</strong></h2><ul><li>null不是对象 虽然typeof null会输出object 但是这时js存在的一个bug 再js最初版本是32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表的是对象然而null表示全零，所以它错误的判断为object。</li></ul><hr><h2 id="4-toString（）为什么可以调用？"><a href="#4-toString（）为什么可以调用？" class="headerlink" title="4.toString（）为什么可以调用？"></a><strong>4.toString（）为什么可以调用？</strong></h2><p>请看下面代码</p><pre><code>var s = new Object(&#39;1&#39;);s.tostring();s = null;</code></pre><p>第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</p><p>第二步: 调用实例方法。</p><p>第三步: 执行完方法立即销毁这个实例。</p><p>整个过程中体现了<strong>基本包装类型</strong>的性质，而基本包装类型是属于基本数据类型 包括boolean，number，string。（红宝书p118）</p><hr><h2 id="5-0-1-0-2为什么不等于0-3？"><a href="#5-0-1-0-2为什么不等于0-3？" class="headerlink" title="5. 0.1+0.2为什么不等于0.3？"></a><strong>5. 0.1+0.2为什么不等于0.3？</strong></h2><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。<br><img src="https://github.com/jiangjie1105/img-hexo/blob/master/0.1+0.2.png?raw=true" srcset="/img/loading.gif" alt="image"></p><hr><h2 id="5-如何理解bignit？"><a href="#5-如何理解bignit？" class="headerlink" title="5.如何理解bignit？"></a><strong>5.如何理解bignit？</strong></h2><ul><li>我所理解的bigint，简单来说就是一种新的数据类型 目前还没有广泛使用 即整数值大于number数据类型支持的范围时，可以使用bigint<h3 id="1-bigint的创建"><a href="#1-bigint的创建" class="headerlink" title="1.bigint的创建"></a><strong>1.bigint的创建</strong></h3></li></ul><ol><li>可以在数字末尾加n<pre><code>console.log(9048394789734987n)</code></pre></li><li>可以用bigint（）构造函数，<pre><code>BigInt(&quot;3432423423242342&quot;);//3432423423242342</code></pre>简单使用如下<br>```<br>10n + 20n;    // → 30n<br>10n - 20n;    // → -10n    </li></ol><p>+10n;         // → TypeError: Cannot convert a BigInt value to a number<br>-10n;         // → -10n<br>10n * 20n;    // → 200n<br>20n / 10n;    // → 2n<br>23n % 10n;    // → 3n<br>10n ** 3n;    // → 1000n    </p><p>```</p><h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ol><li><p>BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。</p></li><li><p>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。</p></li><li><p>不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。</p></li><li><p>当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。</p></li><li><p>元素都为BigInt的数组可以进行sort。</p></li><li><p>BigInt可以正常地进行位运算，如|、&amp;、&lt;&lt;、&gt;&gt;和^</p><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a><strong>浏览器兼容性</strong></h2></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/22/16df110a69c0ae17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-复杂度分析(上)</title>
    <link href="/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>如下代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal (int n) &#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int i &#x3D; 1;</span><br><span class="line">    int j &#x3D; 1;</span><br><span class="line">    for (;i &lt; &#x3D; n ; i++)&#123;</span><br><span class="line">        j &#x3D; 1;</span><br><span class="line">        for (; j&lt;&#x3D; n; ++j) &#123;</span><br><span class="line">            sum &#x3D; sum + i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码二三四行都需要一个unit_time 执行时间，五六行循环执行了n遍，需要2n×unit_time执行时间 第七八行执行了n²次 所以总时间等于(2n²＋2n＋3)*unit_time</p><h2 id="1-大o复杂度表示法"><a href="#1-大o复杂度表示法" class="headerlink" title="1.大o复杂度表示法"></a>1.大o复杂度表示法</h2><h3 id="读数据–运算–写数据"><a href="#读数据–运算–写数据" class="headerlink" title="读数据–运算–写数据"></a>读数据–运算–写数据</h3><p>从cpu角度来讲 每一行都执行着类似操作 大o时间复杂度实际上不是代码的具体执行时间 而是表示代码执行时间随数据规模增长的变化趋势 所以也叫 <strong>渐进时间复杂度</strong> 也称<strong>时间复杂度</strong></p><h2 id="2-时间复杂度分析"><a href="#2-时间复杂度分析" class="headerlink" title="2.时间复杂度分析"></a>2.时间复杂度分析</h2><ol><li><p>只关注时间复杂度次数最多的一段代码，分析一段代码的时间复杂度时，也只关注循环执行次数最多的那一段代码就行了。</p></li><li><p>总的时间复杂度就等于量级最大的那段代码的时间复杂度</p></li><li><p>乘法法则：嵌套的代码的复杂度等于嵌套内外代码的复杂度的乘积  如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 <strong>T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n))</strong>.</p></li></ol><ul><li>非多项式量级</li></ul><ol><li>：O(2 ) 和 O(n!) </li></ol><p>当数据规模很大时这两者算法执行时间会急剧增加，求解问题时间会无限增长 所以很低效 。</p><ul><li>多项式量级</li></ul><ol><li>0（1）</li></ol><p>0（1）只是时间复杂度的一种表示方法，不是执行了一行代码所以 只要语句中不存在循环语句，递归语句，即使有成千上万行代码 时间复杂度都是0（1）.</p><ol start="2"><li><p>O(logn)、O(nlogn)<br>如下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 1 ;</span><br><span class="line">while (i &lt;&#x3D; n) &#123;</span><br><span class="line">    i &#x3D; i * 2；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中实际上就是i的值开始时是1，之后每次循环都乘二 相当于2的x次方等于n ，所以时间复杂度为以2为底log n, <strong>因为对数之间可以互相转换 所以采用大0标记复杂度的时候 可以忽略系数，即 O(Cf(n)) = O(f(n))。</strong></p><ul><li>o（ologn）</li></ul><p>如果一段代码时间复杂度为O（logn）那么循环n次就是o（nlogn）</p><ol start="3"><li>o（m+n），o（m*n）</li></ol><p>代码的复杂度<strong>由两个数据规模</strong>来决定 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">    int sum_1 &#x3D; 0; </span><br><span class="line">    int i &#x3D; 1; </span><br><span class="line">    for (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 &#x3D; sum_1 + i;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int sum_2 &#x3D; 0; </span><br><span class="line">    int j &#x3D; 1;  </span><br><span class="line">    for (; j &lt; n; ++j) &#123;</span><br><span class="line">        sum_2 &#x3D; sum_2 + j;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  return sum_1 + sum_2; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的代码中 m和n是两个数据规模 我们无法评估谁的量级大所以在表示 时间复杂度时就不能用加法准则，所以上面的代码时间复杂的就是0（m+n）<br>所以针对上面的情况，加法规则就不正确了，<br>需要改为<strong>T1(m)+T2(n)=o(f(m) + g(n))</strong> 乘法规则继续有效。</p></li></ol><ul><li>空间复杂度分析 </li></ul><p>空间复杂度的全称就是<strong>渐进空间复杂度表示算法的存储空间与数据规模之间的增长关系</strong>。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p><strong>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，越高阶复杂度的算法，执行效率越低。从低阶到高阶的有：o(1),o(logn),o(n),o(nlogn),o(n²)</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/02/14/hello-world/"/>
    <url>/2019/02/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
